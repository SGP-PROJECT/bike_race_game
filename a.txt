#include <iostream>
using namespace std;
#include <sstream>
#include "SDL/SDL.h"
#include "SDL/SDL_image.h"
#include "SDL/SDL_ttf.h"
#include "constants.h"
#include "string"
#include "coardinate.h"
#include "variable.h"
#include "init.h"
#include "function.h"
#include "collision.h"
#include "process.h"
#include "menu.h"

//bool check_collision(SDL_Rect,SDL_Rect);

bool check_collision_wall(SDL_Rect ,SDL_Rect );
bool is_collision()              //Returns true when collision happen ,otherwise returns false..
{
     SDL_Rect rect;
     rect.x=bike_x;
     rect.y=bike_y;
     rect.w=bike->w;
     rect.h=bike->h;

          for(int i=0;i<SMAX_WALL;i++)    //Check collision of PIPE..
               if(w1[i].get_state())     //When enabled PIPE is found only then check the collision and exit the loop...
               {
                    if (check_collision_wall(rect ,w1[i].get_rect()))   //Check collision of the MARIO and PIPE 0...
                    return true;
                    break;
               }
          for(int i=0;i<BMAX_WALL;i++)    //Check collision of PIPE..
               if(w2[i].get_state())     //When enabled PIPE is found only then check the collision and exit the loop...
               {

                    if (check_collision_wall(rect ,w2[i].get_rect()))   //Check collision of the MARIO and PIPE 0...
                    {
                         return true;
                         break;
                    }

               }
          return false;
}

bool check_collision_wall(SDL_Rect source,SDL_Rect distination)
{
//Detect collision when moving RIGHT or LEFT side...
         if( ((source.x+source.w) < distination.x ) or  source.x > ( distination.x+distination.w))
         {
              if( (bike_stand-bike->h)== distination.y - source.h)
              bike_stand=LAYER_Y;
              return false;
         }
         if(( (source.y+source.h) <= distination.y ))
         {
              bike_stand=distination.y;
              return false;
         }
         if(((source.y+source.h)<=(distination.y+20)) and ( (source.y+source.h)>=distination.y-10 ) )
          {
               bike_stand=distination.y;
               bike_y=distination.y-source.h;
               return false;
          }
         apply_surface(100,300,die,screen);
         SDL_Flip(screen);
         SDL_Delay(2000);
         return true;
}

class cord          //Holds the coardinates of the images
{
     protected:
     SDL_Rect cord_rect;

     public:

     cord(int x=0,int y=0,int w=0,int h=0)
     {
          cord_rect.x=x;
          cord_rect.y=y;
          cord_rect.w=w;
          cord_rect.h=h;
     }
     int get_cord_x()              //Returns the current x coardinate of the object...
     {
          return cord_rect.x;
     }
     int get_cord_y()              //Returns the current y coardinate of the object...
     {
          return cord_rect.y;
     }
     int get_cord_w()
     {
          return cord_rect.w;
     }
     int get_cord_h()
     {
          return cord_rect.h;
     }
     SDL_Rect get_rect()           //Returns rectangle and take width of the picture as a argument..
     {
          return cord_rect;
     }                 //Sets the width and the height of the current picture..
};

class background:public cord
{
     private:

     public:
     background()
     {    }
     background(int x,int y,int w,int h):cord(x,y,w,h)
     {    }
     void add_background_x(int n)
     {
          cord_rect.x+=(n-1);
          if(cord_rect.x < -WIDTH)
          cord_rect.x+=(2*WIDTH);
     }
};
class wall:public cord
{
     private:
     bool state;
     public:
     wall()
     {
          state=false;
     }
     wall(int x,int y,int w,int h):cord(x,y,w,h)
     {
          state=false;
     }
     bool get_state()
     {
          return state;
     }
     void set_state(bool s)
     {
          state=s;
     }
     void add_wall_x(int n)
     {
          cord_rect.x+=n;
          if( cord_rect.x>WIDTH or ( (cord_rect.x+cord_rect.w) < 0) )
          state=false;
          else
          state=true;
     }
};


//bool check_collision(SDL_Rect,SDL_Rect);

bool check_collision_wall(SDL_Rect ,SDL_Rect );
bool is_collision()              //Returns true when collision happen ,otherwise returns false..
{
     SDL_Rect rect;
     rect.x=bike_x;
     rect.y=bike_y;
     rect.w=bike->w;
     rect.h=bike->h;

          for(int i=0;i<SMAX_WALL;i++)    //Check collision of PIPE..
               if(w1[i].get_state())     //When enabled PIPE is found only then check the collision and exit the loop...
               {
                    if (check_collision_wall(rect ,w1[i].get_rect()))   //Check collision of the MARIO and PIPE 0...
                    return true;
                    break;
               }
          for(int i=0;i<BMAX_WALL;i++)    //Check collision of PIPE..
               if(w2[i].get_state())     //When enabled PIPE is found only then check the collision and exit the loop...
               {

                    if (check_collision_wall(rect ,w2[i].get_rect()))   //Check collision of the MARIO and PIPE 0...
                    {
                         return true;
                         break;
                    }

               }
          return false;
}

bool check_collision_wall(SDL_Rect source,SDL_Rect distination)
{
//Detect collision when moving RIGHT or LEFT side...
         if( ((source.x+source.w) < distination.x ) or  source.x > ( distination.x+distination.w))
         {
              if( (bike_stand-bike->h)== distination.y - source.h)
              bike_stand=LAYER_Y;
              return false;
         }
         if(( (source.y+source.h) <= distination.y ))
         {
              bike_stand=distination.y;
              return false;
         }
         if(((source.y+source.h)<=(distination.y+20)) and ( (source.y+source.h)>=distination.y-10 ) )
          {
               bike_stand=distination.y;
               bike_y=distination.y-source.h;
               return false;
          }
         apply_surface(100,300,die,screen);
         SDL_Flip(screen);
         SDL_Delay(2000);
         return true;
}
//Constants for height and width of the screen ..
     const int WIDTH=800;
     const int HEIGHT=600;
     const int BPP=32;

//Constant for Layes..
     const int START_LAYER_Y = 530;        //Starting y position of the base layer or the ground surface of the plane...

//Constants for BIKE...
     const int START_BIKE_X=150;                  //Starting coardinate of BIKE...
     const int FINISH_BIKE_X=250;               //Last positon of BIKE on the screen in x direction..

//constants for layer
     const int LAYER_Y=493;
//constants for wall
     const int SMAX_WALL=5;
     const int BMAX_WALL=4;


void apply_surface(int x,int y,SDL_Surface *source,SDL_Surface *distination,SDL_Rect *clip=NULL)
{
    SDL_Rect offset;
    offset.x=x;
    offset.y=y;
    SDL_BlitSurface(source,clip,distination,&offset);       //Load image to the display screen i.e. on the screen..
}
bool init_all()
{
     if(SDL_Init(SDL_INIT_EVERYTHING)==-1)
     return false;

     screen=SDL_SetVideoMode( WIDTH,HEIGHT,BPP,SDL_SWSURFACE );

    if(screen==NULL)
    {
        return false;
    }

    if(TTF_Init()==-1)                  //Font Initialization...
    {
        return false;
    }


    SDL_WM_SetCaption("BIKE RACE",NULL);
    return true;
}

//Load a image file on screen and returns the address..
SDL_Surface* load_image(std::string filename,int col1=0xFF,int col2=0xFF , int col3=0xFF )
{
    SDL_Surface *loaded_image=NULL;
    SDL_Surface *optimized_image=NULL;

    loaded_image=IMG_Load(filename.c_str());
    if(loaded_image!=NULL)
    {
        optimized_image=SDL_DisplayFormat(loaded_image);
        SDL_FreeSurface(loaded_image);

        if(optimized_image!=NULL)
        {
            SDL_SetColorKey(optimized_image,SDL_SRCCOLORKEY,SDL_MapRGB(optimized_image->format,col1,col2,col3));
        }
    }

    return optimized_image;     //Return the address of the loaded image...
}

bool load_files()
{
     for(int i=0;i<3;i++)
     {
          back[i]=load_image("image/bg2.png");         //Loads the background image..
          if(back[i]==NULL)
          return false;
     }
     bg[0]=background(0,0,back[0]->w,back[0]->h);
     bg[0]=background(WIDTH,0,back[1]->w,back[1]->h);

     upback=load_image("image/bg1.png");     //Loads the uper side of the  background image..
     if(upback==NULL)
     return false;

     bike=load_image("image/bike.PNG");      //Loads the image of bike..
     if(bike==NULL)
     return false;
     bike_y=LAYER_Y-bike->h;

     obs_wall[0]=load_image("image/wall.JPG");
     obs_wall[1]=load_image("image/wall1.JPG");
     if(obs_wall==NULL || obs_wall[1]==NULL)
     return false;

     w1[0]=wall(WIDTH+50,LAYER_Y-obs_wall[0]->h,obs_wall[0]->w,obs_wall[0]->h);
     w1[1]=wall(WIDTH+1350,LAYER_Y-obs_wall[0]->h,obs_wall[0]->w,obs_wall[0]->h);
     w1[2]=wall(WIDTH+3350,LAYER_Y-obs_wall[0]->h,obs_wall[0]->w,obs_wall[0]->h);
     w1[3]=wall(WIDTH+5050,LAYER_Y-obs_wall[0]->h,obs_wall[0]->w,obs_wall[0]->h);
     w1[4]=wall(WIDTH+7100,LAYER_Y-obs_wall[0]->h,obs_wall[0]->w,obs_wall[0]->h);

     w2[0]=wall(WIDTH+2050,LAYER_Y-obs_wall[1]->h,obs_wall[1]->w,obs_wall[1]->h);
     w2[1]=wall(WIDTH+4350,LAYER_Y-obs_wall[1]->h,obs_wall[1]->w,obs_wall[1]->h);
     w2[2]=wall(WIDTH+6050,LAYER_Y-obs_wall[1]->h,obs_wall[1]->w,obs_wall[1]->h);
     w2[3]=wall(WIDTH+7800,LAYER_Y-obs_wall[1]->h,obs_wall[1]->w,obs_wall[1]->h);


     font=TTF_OpenFont("times.ttf",20);      //Font file is loaded....

     time_limit=TTF_RenderText_Solid(font,"Time limit is 1:30 minute",textColor);
     die=TTF_RenderText_Solid(font,"GAME OVER",textColor);

    menu_pic=load_image("image/menu.jpg");
    play_menu=load_image("image/menu_play.jpg");
    instruction_menu=load_image("image/menu_instruction.jpg");
    quit_menu=load_image("image/menu_exit.jpg");
    if(menu_pic==NULL || play_menu==NULL || instruction_menu==NULL || quit_menu==NULL)
    return false;

     return true;
}



int main(int ch,char *cha[])
{
     if(!init_all())
     return 0;

     if(!load_files())
     return 0;

     int opt=start_menu();


     return 1;
}
int start_menu()
{
     bool running=true;
     int x,y;

     bike_process bk;

     while(running)
     while( SDL_PollEvent( &event ) )
     {
          if(event.type == SDL_MOUSEMOTION)
          {
               cerr<<"inside"<<endl;
               x = event.motion.x;
               y = event.motion.y;
               if((x>594) && (x<756) && (y>340) && (y<357))
               {
                    apply_surface(0,0,play_menu,screen);
               }
               else if((x>572) && (x<778) && (y>414) && (y<431))
               {
                    apply_surface(0,0,instruction_menu,screen);
               }
               else if((x>641) && (x<708) && (y>490) && (y<506))
               {
                    apply_surface(0,0,quit_menu,screen);
               }
               else
               apply_surface(0,0,menu_pic,screen);
               SDL_Flip(screen);

        }
        else
          apply_surface(0,0,menu_pic,screen);
          SDL_Flip(screen);
        if(event.type == SDL_MOUSEBUTTONDOWN)
          {
               x = event.motion.x;
               y = event.motion.y;
               if((x>594) && (x<756) && (y>340) && (y<357))
               {
                    while(bk.process())
                    {
                         SDL_Flip(screen);
                    }
               }
               else if((x>572) && (x<778) && (y>414) && (y<431))
               {
                    apply_surface(0,0,instruction_menu,screen);
               }
               else if((x>641) && (x<708) && (y>490) && (y<506))
               {
                    return 0;
               }
          }
     }

     return 0;
}



class bike_process
{
     private:

     public:


void load_layer(int x=0 ,int y=0)
{

     apply_surface(bg[0].get_cord_x(),0,back[0],screen);      //Blit the screen;
     apply_surface(bg[1].get_cord_x(),0,back[1],screen);      //Blit the screen;
     apply_surface(0,0,upback,screen);

     for(int i=0;i<SMAX_WALL;i++)
     if(w1[i].get_state())
     apply_surface(w1[i].get_cord_x(),w1[i].get_cord_y(),obs_wall[0],screen);

     for(int i=0;i<BMAX_WALL;i++)
     if(w2[i].get_state())
     apply_surface(w2[i].get_cord_x(),w2[1].get_cord_y(),obs_wall[1],screen);
     apply_surface(bike_x,bike_y,bike,screen);         //bike is blitted..

}

void change_coardinate(int );       //Set the coardinate of the labels..

bool process();

};

bool bike_process::process()
{
     while( SDL_PollEvent(&event) )
     {
          if(event.type==SDL_QUIT)
          return false;
     }

     if( keystate[SDLK_ESCAPE] || game_on==0 || time_gap>=90)
     return false;

     if(keystate[SDLK_SPACE] or keystate[SDLK_UP])                //If space is pressed...
     {
          if(jump_state==0)
          jump_state=36;                     //set the jump or SPACE state in 20*2 steps...

     }
     if( (bike_y <(bike_stand-bike->h)) or jump_state>=16  )    //Condition true untill the MARIO goes upward and downward to surface below it..
     {
          int jump_height;
          jump_height=19-jump_state;         //using the formula n/2*(n+1)...
          bike_y += jump_height;
          jump_state--;
          if(jump_state==0)
          jump_state--;
     }
     else
     {
          bike_y=bike_stand-bike->h;
          jump_state=0;
     }

     if(keystate[SDLK_RIGHT])
     if(speed<=20)                 //Speed only increase to 10..
     speed++;
     if(keystate[SDLK_LEFT])
     if(speed>0)                    //speed cannot be less than 0..
     speed--;

     if(bike_x < FINISH_BIKE_X)
     bike_x+=speed;
     else
     change_coardinate(-speed/2);
     change_coardinate(0);

     load_layer();
     if(( w2[BMAX_WALL-1].get_cord_x())+w2[BMAX_WALL-1].get_cord_w() < 0)
     {
         apply_surface(100,300,die,screen);
         SDL_Flip(screen);
         SDL_Delay(2000);
         return false;
     }

     std::stringstream time;
     //Convert the timer's time to a string
     time_gap =(SDL_GetTicks() - start_time)/1000;
     int mm=time_gap/60;
     int ss=time_gap%60;
     time << "Timer: " << mm<<":"<<ss;
     times=TTF_RenderText_Solid(font,time.str().c_str(),textColor);
     apply_surface(600,50,times,screen);
     apply_surface(500,55+times->h,time_limit,screen);

     return true;
}

